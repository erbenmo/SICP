;; a)
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
	     (env-loop (enclosing-environment env)))
	    ((eq? var (car vars))
	     (if (eq (car vals) *unassigned*)
		 (error "target var is not assigned yet")
		 (car vals)))
	    (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
	(error "Unbound variable -- GET!" var)
	(let ((frame (first-frame env)))
	  (scan (frame-variables frame)
		(frame-values frame)))))
  (env-loop env))

;; b-)
(define (scan-out-defines body)
  (define (rec body cur-body)
    (if (null? cur-body)
	'ok
	(let ((cur (car cur-body)))
	  (if (definition? cur)
	      (let ((var (definition-variable cur)))
		(set-car! cur 'definition)
		(set! body (list 'let
				 (list (list var *unassigned*))
				 body)))
	      (rec body (cdr cur-body))))))
  (rec body body))


;; b)
(define (scan-out-defines body)
  (let ((assign-slot '())
	(assignment '())
	(let-body '()))
    (define (scan-iter clauses)
      (if (null? clauses)
	  '()
	  (let ((cur (car clauses)))
	    (if (definition cur)
		(let ((var (definition-variable cur))
		      (val (definition-value cur)))
		  (set! assign-slot (cons (list var '*unassigned*) assign-slot))
		  (set! assignment (cons (list 'set! var val) assignment)))
		(set! let-body (cons cur let-body)))
	    (scan-iter (cdr clauses)))))
    (scan-iter body)
    (if (null? assign-slot)
	body
	(append (list 'let assign-slot) assignment let-body))))


;; c)
(define (make-procedure parameters body env)
  (list 'procedure parameters (scan-out-defines body) env))